// lib/core/models/client_models.dart

// Add these classes to your existing client_models.dart file

import 'package:equatable/equatable.dart';

/// Represents a document uploaded by the user before processing
class UploadedDocument extends Equatable {
  final String id;
  final String fileName;
  final String filePath;
  final String? password;
  final int ownerParticipantId;
  final FinancialInstitution institution;
  final DateTime uploadedAt;

  const UploadedDocument({
    required this.id,
    required this.fileName,
    required this.filePath,
    this.password,
    required this.ownerParticipantId,
    required this.institution,
    required this.uploadedAt,
  });

  @override
  List<Object?> get props => [
        id,
        fileName,
        filePath,
        password,
        ownerParticipantId,
        institution,
        uploadedAt,
      ];
}

/// Financial institutions supported by the app
enum FinancialInstitution {
  hsbc,
  equity,
  mpesa,
  custom;

  String get displayName {
    switch (this) {
      case FinancialInstitution.hsbc:
        return 'HSBC';
      case FinancialInstitution.equity:
        return 'Equity';
      case FinancialInstitution.mpesa:
        return 'M-PESA';
      case FinancialInstitution.custom:
        return 'Custom';
    }
  }

  String get logoPath {
    switch (this) {
      case FinancialInstitution.hsbc:
        return 'assets/banks/hsbc.png';
      case FinancialInstitution.equity:
        return 'assets/banks/equity.png';
      case FinancialInstitution.mpesa:
        return 'assets/banks/mpesa.png';
      case FinancialInstitution.custom:
        return 'assets/banks/custom.png';
    }
  }
}

/// Represents a transaction extracted from a PDF but not yet saved to database
class ParsedTransaction extends Equatable {
  final String id; // Temporary ID for UI tracking
  final DateTime date;
  final String vendorName;
  final double amount;
  final String? category;
  final String? account;
  final String? reason;
  final bool useMemory; // Maps to "Use Memory" checkbox

  const ParsedTransaction({
    required this.id,
    required this.date,
    required this.vendorName,
    required this.amount,
    this.category,
    this.account,
    this.reason,
    this.useMemory = false,
  });

  ParsedTransaction copyWith({
    String? id,
    DateTime? date,
    String? vendorName,
    double? amount,
    String? category,
    String? account,
    String? reason,
    bool? useMemory,
  }) {
    return ParsedTransaction(
      id: id ?? this.id,
      date: date ?? this.date,
      vendorName: vendorName ?? this.vendorName,
      amount: amount ?? this.amount,
      category: category ?? this.category,
      account: account ?? this.account,
      reason: reason ?? this.reason,
      useMemory: useMemory ?? this.useMemory,
    );
  }

  @override
  List<Object?> get props => [
        id,
        date,
        vendorName,
        amount,
        category,
        account,
        reason,
        useMemory,
      ];
}

/// Result of parsing a document
class ParseResult extends Equatable {
  final bool success;
  final String? errorMessage;
  final List<ParsedTransaction> transactions;
  final UploadedDocument document;

  const ParseResult({
    required this.success,
    this.errorMessage,
    required this.transactions,
    required this.document,
  });

  @override
  List<Object?> get props => [success, errorMessage, transactions, document];
}

/// Validation result for document parseability
class ValidationResult extends Equatable {
  final bool canParse;
  final String? errorMessage;
  final List<String> missingCheckpoints;

  const ValidationResult({
    required this.canParse,
    this.errorMessage,
    this.missingCheckpoints = const [],
  });

  const ValidationResult.success()
      : canParse = true,
        errorMessage = null,
        missingCheckpoints = const [];

  const ValidationResult.failure({
    required String error,
    List<String> missing = const [],
  })  : canParse = false,
        errorMessage = error,
        missingCheckpoints = missing;

  @override
  List<Object?> get props => [canParse, errorMessage, missingCheckpoints];
}

// Existing models (Template, Account, Category, etc.) remain here...


==========================================================================================

// lib/core/services/parser/custom_parser.dart

import 'dart:io';
import 'package:uuid/uuid.dart';
import '../../models/client_models.dart';
import 'parser_interface.dart';

/// Parser for custom/generic bank statements
/// 
/// This parser attempts to handle statements from unknown banks
/// by looking for common patterns across different statement formats.
/// 
/// Expected Minimum Structure:
/// - Some form of date column (various formats accepted)
/// - Description/vendor column
/// - Amount column (may be combined or separate debit/credit)
/// 
/// This parser is more lenient and uses heuristics to identify:
/// - Transaction tables (by finding repeating patterns)
/// - Date formats (tries multiple common formats)
/// - Amount formats (handles various currency symbols and separators)
class CustomParser implements StatementParser {
  @override
  FinancialInstitution get institution => FinancialInstitution.custom;

  /// Checkpoints to verify in PDF:
  /// 1. At least one table-like structure
  /// 2. Repeating date patterns
  /// 3. Repeating number patterns (amounts)
  /// 4. Minimum 3 columns detected
  /// 
  /// This is more lenient than institution-specific parsers
  @override
  Future<ValidationResult> validateDocument(
    File pdfFile, {
    String? password,
  }) async {
    // TODO: Implement custom validation
    // 
    // Strategy:
    // 1. Extract all text
    // 2. Look for tabular data (aligned columns, repeating patterns)
    // 3. Try to identify date column (test multiple formats)
    // 4. Try to identify amount column (look for currency patterns)
    // 5. If both found, consider it parseable
    
    return const ValidationResult.success();
  }

  @override
  Future<ParseResult> parseDocument(
    File pdfFile,
    UploadedDocument documentMetadata, {
    String? password,
  }) async {
    // TODO: Implement custom parsing
    // 
    // Strategy:
    // 1. Extract table data using heuristics
    // 2. Identify which columns contain dates, vendors, amounts
    // 3. Parse each row using flexible patterns
    // 4. Apply confidence scoring (warn user about uncertain parses)
    // 5. Return best-effort results
    
    return ParseResult(
      success: true,
      transactions: _generateSampleTransactions(documentMetadata),
      document: documentMetadata,
    );
  }

  @override
  Future<bool> unlockPdf(File pdfFile, String? password) async {
    return true;
  }

  @override
  bool containsInstitutionMarkers(String pdfText) {
    // Custom parser doesn't look for specific markers
    // Just check if it looks like a financial document
    final financialKeywords = [
      'statement',
      'account',
      'balance',
      'transaction',
      'debit',
      'credit',
      'date',
    ];
    
    final lowerText = pdfText.toLowerCase();
    return financialKeywords.any((keyword) => lowerText.contains(keyword));
  }

  @override
  List<List<String>> extractTableData(String pdfText) {
    // TODO: Implement intelligent table detection
    // Look for patterns of aligned text that repeats
    return [];
  }

  @override
  String normalizeVendorName(String rawVendor) {
    // Generic cleaning
    return rawVendor
        .trim()
        .replaceAll(RegExp(r'\s+'), ' '); // Normalize whitespace
  }

  @override
  DateTime? parseDate(String dateString) {
    // Try multiple common date formats
    final formats = [
      _tryParseDDMMYYYY,
      _tryParseDDMMMYYYY,
      _tryParseYYYYMMDD,
      _tryParseMMDDYYYY,
    ];
    
    for (final format in formats) {
      final result = format(dateString);
      if (result != null) return result;
    }
    
    return null;
  }

  DateTime? _tryParseDDMMYYYY(String dateString) {
    try {
      final parts = dateString.split(RegExp(r'[/\-.]'));
      if (parts.length != 3) return null;
      
      return DateTime(
        int.parse(parts[2]),
        int.parse(parts[1]),
        int.parse(parts[0]),
      );
    } catch (e) {
      return null;
    }
  }

  DateTime? _tryParseDDMMMYYYY(String dateString) {
    final months = {
      'jan': 1, 'feb': 2, 'mar': 3, 'apr': 4,
      'may': 5, 'jun': 6, 'jul': 7, 'aug': 8,
      'sep': 9, 'oct': 10, 'nov': 11, 'dec': 12,
    };
    
    try {
      final parts = dateString.toLowerCase().split(' ');
      if (parts.length != 3) return null;
      
      final day = int.parse(parts[0]);
      final month = months[parts[1].substring(0, 3)];
      final year = int.parse(parts[2]);
      
      if (month == null) return null;
      
      return DateTime(year, month, day);
    } catch (e) {
      return null;
    }
  }

  DateTime? _tryParseYYYYMMDD(String dateString) {
    try {
      final parts = dateString.split(RegExp(r'[/\-.]'));
      if (parts.length != 3) return null;
      
      return DateTime(
        int.parse(parts[0]),
        int.parse(parts[1]),
        int.parse(parts[2]),
      );
    } catch (e) {
      return null;
    }
  }

  DateTime? _tryParseMMDDYYYY(String dateString) {
    try {
      final parts = dateString.split(RegExp(r'[/\-.]'));
      if (parts.length != 3) return null;
      
      return DateTime(
        int.parse(parts[2]),
        int.parse(parts[0]),
        int.parse(parts[1]),
      );
    } catch (e) {
      return null;
    }
  }

  @override
  double? parseAmount(String amountString) {
    // Remove all currency symbols and separators
    final cleaned = amountString
        .replaceAll(RegExp(r'[^\d.\-+]'), '')
        .trim();
    
    try {
      return double.parse(cleaned);
    } catch (e) {
      return null;
    }
  }

  List<ParsedTransaction> _generateSampleTransactions(
    UploadedDocument document,
  ) {
    final uuid = const Uuid();
    return List.generate(
      8,
      (index) => ParsedTransaction(
        id: uuid.v4(),
        date: DateTime.now().subtract(Duration(days: index * 2)),
        vendorName: 'Greggs PLC',
        amount: -2.90,
        useMemory: false,
      ),
    );
  }
}

==========================================================================================


// lib/core/services/document_service.dart

import 'dart:io';
import 'package:logging/logging.dart';
import 'package:uuid/uuid.dart';
import '../models/client_models.dart';
import 'parser/parser_factory.dart';
import 'parser/parser_interface.dart';

/// Service for handling document upload, validation, and parsing
class DocumentService {
  final Logger _logger = Logger('DocumentService');
  final Uuid _uuid = const Uuid();

  /// Creates an UploadedDocument from file metadata
  UploadedDocument createUploadedDocument({
    required String fileName,
    required String filePath,
    String? password,
    required int ownerParticipantId,
    required FinancialInstitution institution,
  }) {
    return UploadedDocument(
      id: _uuid.v4(),
      fileName: fileName,
      filePath: filePath,
      password: password,
      ownerParticipantId: ownerParticipantId,
      institution: institution,
      uploadedAt: DateTime.now(),
    );
  }

  /// Validates that a document can be parsed by the selected parser
  Future<ValidationResult> validateDocument(
    UploadedDocument document,
  ) async {
    try {
      _logger.info('Validating document: ${document.fileName}');
      
      final file = File(document.filePath);
      if (!await file.exists()) {
        return const ValidationResult.failure(
          error: 'File not found. Please upload the document again.',
        );
      }

      // Get appropriate parser
      final parser = ParserFactory.getParser(document.institution);
      
      // Validate with parser
      final result = await parser.validateDocument(
        file,
        password: document.password,
      );

      if (result.canParse) {
        _logger.info('Document validation successful: ${document.fileName}');
      } else {
        _logger.warning(
          'Document validation failed: ${document.fileName}. '
          'Reason: ${result.errorMessage}',
        );
      }

      return result;
    } catch (e, st) {
      _logger.severe('Error validating document', e, st);
      return ValidationResult.failure(
        error: 'An error occurred while validating the document: $e',
      );
    }
  }

  /// Parses a document and extracts transactions
  Future<ParseResult> parseDocument(
    UploadedDocument document,
  ) async {
    try {
      _logger.info('Parsing document: ${document.fileName}');
      
      final file = File(document.filePath);
      if (!await file.exists()) {
        return ParseResult(
          success: false,
          errorMessage: 'File not found. Please upload the document again.',
          transactions: const [],
          document: document,
        );
      }

      // Get appropriate parser
      final parser = ParserFactory.getParser(document.institution);
      
      // Parse document
      final result = await parser.parseDocument(
        file,
        document,
        password: document.password,
      );

      if (result.success) {
        _logger.info(
          'Document parsed successfully: ${document.fileName}. '
          'Found ${result.transactions.length} transactions.',
        );
      } else {
        _logger.warning(
          'Document parsing failed: ${document.fileName}. '
          'Reason: ${result.errorMessage}',
        );
      }

      return result;
    } catch (e, st) {
      _logger.severe('Error parsing document', e, st);
      return ParseResult(
        success: false,
        errorMessage: 'An error occurred while parsing the document: $e',
        transactions: const [],
        document: document,
      );
    }
  }

  /// Cleans up a document file from storage
  Future<void> cleanupDocument(UploadedDocument document) async {
    try {
      final file = File(document.filePath);
      if (await file.exists()) {
        await file.delete();
        _logger.info('Cleaned up document: ${document.fileName}');
      }
    } catch (e, st) {
      _logger.warning('Failed to cleanup document: ${document.fileName}', e, st);
      // Non-critical error, don't throw
    }
  }

  /// Validates that a file is a valid PDF
  bool isValidPdf(String filePath) {
    try {
      final file = File(filePath);
      if (!file.existsSync()) return false;
      
      // Check file extension
      if (!filePath.toLowerCase().endsWith('.pdf')) return false;
      
      // Read first few bytes to check PDF header
      final bytes = file.readAsBytesSync();
      if (bytes.length < 5) return false;
      
      // PDF files start with %PDF
      final header = String.fromCharCodes(bytes.take(4));
      return header == '%PDF';
    } catch (e) {
      _logger.warning('Error checking PDF validity: $e');
      return false;
    }
  }

  /// Gets a human-readable file size
  String getFileSize(String filePath) {
    try {
      final file = File(filePath);
      final bytes = file.lengthSync();
      
      if (bytes < 1024) return '$bytes B';
      if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)} KB';
      return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
    } catch (e) {
      return 'Unknown';
    }
  }
}


==========================================================================================


// lib/features/home/home_viewmodel.dart

import 'package:flutter/foundation.dart';
import 'package:logging/logging.dart';
import '../../core/context.dart';
import '../../core/models/client_models.dart';
import '../../core/models/models.dart' as models;
import '../../core/services/document_service.dart';
import '../../core/services/participant_service.dart';
import '../../core/services/budget_service.dart';

class HomeViewModel extends ChangeNotifier {
  final DocumentService _documentService;
  final ParticipantService _participantService;
  final BudgetService _budgetService;
  final AppContext _appContext;
  final Logger _logger = Logger('HomeViewModel');

  // State
  List<UploadedDocument> _uploadedDocuments = [];
  List<ParsedTransaction> _extractedTransactions = [];
  List<models.Participant> _participants = [];
  List<models.Template> _templateHistory = [];
  bool _isLoading = false;
  bool _hasRunAudit = false;
  String? _errorMessage;

  HomeViewModel({
    required DocumentService documentService,
    required ParticipantService participantService,
    required BudgetService budgetService,
    required AppContext appContext,
  })  : _documentService = documentService,
        _participantService = participantService,
        _budgetService = budgetService,
        _appContext = appContext {
    _initialize();
  }

  // Getters
  List<UploadedDocument> get uploadedDocuments => _uploadedDocuments;
  List<ParsedTransaction> get extractedTransactions => _extractedTransactions;
  List<models.Participant> get participants => _participants;
  List<models.Template> get templateHistory => _templateHistory;
  bool get isLoading => _isLoading;
  bool get hasRunAudit => _hasRunAudit;
  String? get errorMessage => _errorMessage;
  bool get hasDocuments => _uploadedDocuments.isNotEmpty;
  bool get hasTransactions => _extractedTransactions.isNotEmpty;

  int? get currentParticipantId => _appContext.participantId;

  Future<void> _initialize() async {
    await loadParticipants();
    await loadTemplateHistory();
  }

  /// Loads all participants from the database
  Future<void> loadParticipants() async {
    try {
      _participants = await _participantService.getAllParticipants();
      notifyListeners();
    } catch (e, st) {
      _logger.severe('Error loading participants', e, st);
    }
  }

  /// Loads template history for the current user
  Future<void> loadTemplateHistory() async {
    try {
      _templateHistory = await _budgetService.templateService.getAllTemplates();
      notifyListeners();
    } catch (e, st) {
      _logger.severe('Error loading template history', e, st);
    }
  }

  /// Adds a document to the upload queue
  Future<bool> addDocument({
    required String fileName,
    required String filePath,
    String? password,
    required int ownerParticipantId,
    required FinancialInstitution institution,
  }) async {
    try {
      _errorMessage = null;

      // Validate PDF
      if (!_documentService.isValidPdf(filePath)) {
        _errorMessage = 'Invalid PDF file. Please select a valid PDF document.';
        notifyListeners();
        return false;
      }

      // Create document
      final document = _documentService.createUploadedDocument(
        fileName: fileName,
        filePath: filePath,
        password: password,
        ownerParticipantId: ownerParticipantId,
        institution: institution,
      );

      // Validate document can be parsed
      _isLoading = true;
      notifyListeners();

      final validationResult = await _documentService.validateDocument(document);

      _isLoading = false;

      if (!validationResult.canParse) {
        _errorMessage = validationResult.errorMessage ??
            'Document could not be understood. Please check:\n'
            '${validationResult.missingCheckpoints.join('\n')}';
        notifyListeners();
        return false;
      }

      // Add to list
      _uploadedDocuments.add(document);
      _logger.info('Document added: $fileName');
      notifyListeners();
      return true;
    } catch (e, st) {
      _logger.severe('Error adding document', e, st);
      _errorMessage = 'Failed to add document: $e';
      _isLoading = false;
      notifyListeners();
      return false;
    }
  }

  /// Removes a document from the upload queue
  void removeDocument(String documentId) {
    final document = _uploadedDocuments.firstWhere(
      (doc) => doc.id == documentId,
      orElse: () => throw Exception('Document not found'),
    );

    _uploadedDocuments.removeWhere((doc) => doc.id == documentId);
    _documentService.cleanupDocument(document);
    _logger.info('Document removed: ${document.fileName}');
    notifyListeners();
  }

  /// Runs audit on all uploaded documents
  Future<void> runAudit() async {
    if (_uploadedDocuments.isEmpty) {
      _errorMessage = 'Please upload at least one document before running audit.';
      notifyListeners();
      return;
    }

    try {
      _isLoading = true;
      _errorMessage = null;
      _extractedTransactions.clear();
      notifyListeners();

      // Parse each document
      for (final document in _uploadedDocuments) {
        final parseResult = await _documentService.parseDocument(document);

        if (parseResult.success) {
          _extractedTransactions.addAll(parseResult.transactions);
        } else {
          _logger.warning(
            'Failed to parse ${document.fileName}: ${parseResult.errorMessage}',
          );
        }
      }

      _hasRunAudit = true;
      _isLoading = false;
      _logger.info('Audit completed. Found ${_extractedTransactions.length} transactions.');
      notifyListeners();
    } catch (e, st) {
      _logger.severe('Error running audit', e, st);
      _errorMessage = 'Failed to run audit: $e';
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Updates a parsed transaction
  void updateTransaction(ParsedTransaction updatedTransaction) {
    final index = _extractedTransactions.indexWhere(
      (t) => t.id == updatedTransaction.id,
    );

    if (index != -1) {
      _extractedTransactions[index] = updatedTransaction;
      notifyListeners();
    }
  }

  /// Toggles the "Use Memory" checkbox for a transaction
  void toggleUseMemory(String transactionId) {
    final index = _extractedTransactions.indexWhere((t) => t.id == transactionId);
    if (index != -1) {
      final transaction = _extractedTransactions[index];
      _extractedTransactions[index] = transaction.copyWith(
        useMemory: !transaction.useMemory,
      );
      notifyListeners();
    }
  }

  /// Refreshes the extracted transactions (re-parses documents)
  Future<void> refreshTransactions() async {
    await runAudit();
  }

  /// Clears all extracted transactions
  void clearTransactions() {
    _extractedTransactions.clear();
    _hasRunAudit = false;
    notifyListeners();
  }

  /// Clears all documents and resets state
  void reset() {
    for (final doc in _uploadedDocuments) {
      _documentService.cleanupDocument(doc);
    }
    _uploadedDocuments.clear();
    _extractedTransactions.clear();
    _hasRunAudit = false;
    _errorMessage = null;
    notifyListeners();
  }

  /// Deletes a template from history
  Future<void> deleteTemplate(int templateId) async {
    try {
      final success = await _budgetService.templateService.deleteTemplate(templateId);
      if (success) {
        _templateHistory.removeWhere((t) => t.templateId == templateId);
        _logger.info('Template deleted: $templateId');
        notifyListeners();
      }
    } catch (e, st) {
      _logger.severe('Error deleting template', e, st);
      _errorMessage = 'Failed to delete template: $e';
      notifyListeners();
    }
  }

  @override
  void dispose() {
    // Cleanup any temporary files
    for (final doc in _uploadedDocuments) {
      _documentService.cleanupDocument(doc);
    }
    super.dispose();
  }
}



==========================================================================================

// lib/features/home/home_view.dart

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../core/theme/app_theme.dart';
import '../../shared/widgets/app_header.dart';
import 'home_viewmodel.dart';
import 'widgets/document_ingestion_widget.dart';
import 'widgets/extracted_transactions_widget.dart';
import 'widgets/side_panel.dart';

class HomeView extends StatelessWidget {
  const HomeView({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final viewModel = context.watch<HomeViewModel>();
    final mediaQuery = MediaQuery.of(context);
    final isWideScreen = mediaQuery.size.width > 1024;

    return Scaffold(
      backgroundColor: AppTheme.backgroundColor,
      body: SafeArea(
        child: Column(
          children: [
            const AppHeader(
              subtitle: 'Document Analysis & Transaction Extraction',
            ),
            Expanded(
              child: isWideScreen
                  ? _buildWideScreenLayout(context, viewModel)
                  : _buildNarrowScreenLayout(context, viewModel),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildWideScreenLayout(
    BuildContext context,
    HomeViewModel viewModel,
  ) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Main content area
        Expanded(
          flex: 3,
          child: _buildMainContent(context, viewModel),
        ),
        // Side panel
        Container(
          width: 350,
          decoration: BoxDecoration(
            color: AppTheme.surface,
            border: Border(
              left: BorderSide(color: AppTheme.border, width: 1),
            ),
          ),
          child: const SidePanel(),
        ),
      ],
    );
  }

  Widget _buildNarrowScreenLayout(
    BuildContext context,
    HomeViewModel viewModel,
  ) {
    return _buildMainContent(context, viewModel);
  }

  Widget _buildMainContent(
    BuildContext context,
    HomeViewModel viewModel,
  ) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(AppTheme.spacingLg),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Data handling notice
          _buildDataHandlingNotice(context),
          const SizedBox(height: AppTheme.spacingLg),

          // Document ingestion
          const DocumentIngestionWidget(),
          const SizedBox(height: AppTheme.spacingLg),

          // Extracted transactions (only shown after audit)
          if (viewModel.hasRunAudit) ...[
            const ExtractedTransactionsWidget(),
          ],

          // Error message
          if (viewModel.errorMessage != null) ...[
            const SizedBox(height: AppTheme.spacingMd),
            _buildErrorMessage(context, viewModel.errorMessage!),
          ],
        ],
      ),
    );
  }

  Widget _buildDataHandlingNotice(BuildContext context) {
    return Row(
      children: [
        Icon(
          Icons.shield_outlined,
          color: AppTheme.success,
          size: 20,
        ),
        const SizedBox(width: AppTheme.spacingXs),
        Expanded(
          child: RichText(
            text: TextSpan(
              style: AppTheme.bodySmall.copyWith(
                color: AppTheme.textSecondary,
              ),
              children: [
                const TextSpan(
                  text: 'Your financial documents never leave your device. ',
                ),
                TextSpan(
                  text: 'Learn more about Budget Audit data handling here',
                  style: TextStyle(
                    color: AppTheme.primaryPink,
                    decoration: TextDecoration.underline,
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildErrorMessage(BuildContext context, String message) {
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingMd),
      decoration: BoxDecoration(
        color: AppTheme.error.withOpacity(0.1),
        border: Border.all(color: AppTheme.error, width: 1),
        borderRadius: BorderRadius.circular(AppTheme.radiusMd),
      ),
      child: Row(
        children: [
          Icon(Icons.error_outline, color: AppTheme.error, size: 20),
          const SizedBox(width: AppTheme.spacingMd),
          Expanded(
            child: Text(
              message,
              style: AppTheme.bodySmall.copyWith(color: AppTheme.error),
            ),
          ),
        ],
      ),
    );
  }
}


==========================================================================================


// lib/shared/widgets/app_header.dart

import 'package:flutter/material.dart';
import '../../core/theme/app_theme.dart';

class AppHeader extends StatelessWidget {
  final String? subtitle;
  final double? logoHeight;
  final EdgeInsets padding;

  const AppHeader({
    Key? key,
    this.subtitle,
    this.logoHeight,
    this.padding = const EdgeInsets.symmetric(vertical: 12, horizontal: 24),
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final mediaQuery = MediaQuery.of(context);
    final screenHeight = mediaQuery.size.height;
    
    // Calculate max height (1/8th of screen)
    final maxHeaderHeight = screenHeight / 8;
    
    // Use provided logoHeight or calculate based on constraints
    final effectiveLogoHeight = logoHeight ?? (maxHeaderHeight * 0.6);

    return Container(
      padding: padding,
      decoration: BoxDecoration(
        color: AppTheme.backgroundColor,
        border: Border(
          bottom: BorderSide(color: AppTheme.border, width: 1),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Logo
          Image.asset(
            'assets/logo.png',
            height: effectiveLogoHeight.clamp(40.0, 80.0),
            fit: BoxFit.contain,
            errorBuilder: (context, error, stackTrace) {
              // Fallback if logo image is missing
              return Text(
                'BUDGET AUDIT',
                style: AppTheme.h2.copyWith(
                  color: AppTheme.primaryPink,
                  fontWeight: FontWeight.w700,
                ),
              );
            },
          ),
          
          // Subtitle
          if (subtitle != null) ...[
            const SizedBox(height: AppTheme.spacing2xs),
            Text(
              subtitle!,
              style: AppTheme.bodySmall.copyWith(
                color: AppTheme.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ],
      ),
    );
  }
}



// lib/shared/widgets/app_header.dart

import 'package:flutter/material.dart';
import '../../core/theme/app_theme.dart';

class AppHeader extends StatelessWidget {
  final String? subtitle;
  final double? logoHeight;
  final EdgeInsets padding;

  const AppHeader({
    Key? key,
    this.subtitle,
    this.logoHeight,
    this.padding = const EdgeInsets.symmetric(vertical: 12, horizontal: 24),
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final mediaQuery = MediaQuery.of(context);
    final screenHeight = mediaQuery.size.height;
    
    // Calculate max height (1/8th of screen)
    final maxHeaderHeight = screenHeight / 8;
    
    // Use provided logoHeight or calculate based on constraints
    final effectiveLogoHeight = logoHeight ?? (maxHeaderHeight * 0.6);

    return Container(
      padding: padding,
      decoration: BoxDecoration(
        color: AppTheme.backgroundColor,
        border: Border(
          bottom: BorderSide(color: AppTheme.border, width: 1),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Logo
          Image.asset(
            'assets/logo.png',
            height: effectiveLogoHeight.clamp(40.0, 80.0),
            fit: BoxFit.contain,
            errorBuilder: (context, error, stackTrace) {
              // Fallback if logo image is missing
              return Text(
                'BUDGET AUDIT',
                style: AppTheme.h2.copyWith(
                  color: AppTheme.primaryPink,
                  fontWeight: FontWeight.w700,
                ),
              );
            },
          ),
          
          // Subtitle
          if (subtitle != null) ...[
            const SizedBox(height: AppTheme.spacing2xs),
            Text(
              subtitle!,
              style: AppTheme.bodySmall.copyWith(
                color: AppTheme.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ],
      ),
    );
  }
}





==========================================================================================

// lib/features/home/widgets/document_ingestion_widget.dart

import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../core/models/client_models.dart';
import '../../../core/theme/app_theme.dart';
import '../home_viewmodel.dart';
import 'document_card.dart';

class DocumentIngestionWidget extends StatefulWidget {
  const DocumentIngestionWidget({Key? key}) : super(key: key);

  @override
  State<DocumentIngestionWidget> createState() =>
      _DocumentIngestionWidgetState();
}

class _DocumentIngestionWidgetState extends State<DocumentIngestionWidget> {
  final _formKey = GlobalKey<FormState>();
  final _passwordController = TextEditingController();
  
  String? _selectedFilePath;
  String? _selectedFileName;
  int? _selectedOwnerId;
  FinancialInstitution? _selectedInstitution;

  @override
  void dispose() {
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final viewModel = context.watch<HomeViewModel>();

    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingLg),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(AppTheme.radiusXl),
        border: Border.all(color: AppTheme.border, width: 1),
      ),
      child: Form(
        key: _formKey,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Enter your bank statement for analysis. Information about each transaction will be automatically read and auto filled',
              style: AppTheme.bodyMedium.copyWith(
                color: AppTheme.textSecondary,
              ),
            ),
            const SizedBox(height: AppTheme.spacingLg),

            // Browse Document
            _buildBrowseDocument(),
            const SizedBox(height: AppTheme.spacingMd),

            // Password (optional)
            _buildPasswordField(),
            const SizedBox(height: AppTheme.spacingMd),

            // Document Owner
            _buildDocumentOwner(viewModel),
            const SizedBox(height: AppTheme.spacingMd),

            // Financial Institution
            _buildInstitutionSelector(),
            const SizedBox(height: AppTheme.spacingLg),

            // Action Buttons
            _buildActionButtons(viewModel),
            
            // Uploaded Documents List
            if (viewModel.hasDocuments) ...[
              const SizedBox(height: AppTheme.spacingLg),
              const Divider(),
              const SizedBox(height: AppTheme.spacingMd),
              _buildUploadedDocumentsList(viewModel),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildBrowseDocument() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Text(
              'Browse Document (Only PDF)',
              style: AppTheme.label,
            ),
            const SizedBox(width: 4),
            Text(
              '*',
              style: AppTheme.label.copyWith(color: AppTheme.error),
            ),
          ],
        ),
        const SizedBox(height: AppTheme.spacingXs),
        InkWell(
          onTap: _pickFile,
          child: Container(
            height: 120,
            decoration: BoxDecoration(
              color: AppTheme.surface,
              border: Border.all(
                color: _selectedFilePath != null
                    ? AppTheme.primaryPink
                    : AppTheme.border,
                width: _selectedFilePath != null ? 2 : 1,
              ),
              borderRadius: BorderRadius.circular(AppTheme.radiusSm),
            ),
            child: Center(
              child: _selectedFilePath != null
                  ? Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(
                          Icons.check_circle,
                          color: AppTheme.primaryPink,
                          size: 32,
                        ),
                        const SizedBox(height: AppTheme.spacingXs),
                        Text(
                          _selectedFileName!,
                          style: AppTheme.bodySmall.copyWith(
                            color: AppTheme.textPrimary,
                            fontWeight: FontWeight.w500,
                          ),
                          textAlign: TextAlign.center,
                        ),
                      ],
                    )
                  : Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(
                          Icons.add_circle_outline,
                          color: AppTheme.textSecondary,
                          size: 32,
                        ),
                        const SizedBox(height: AppTheme.spacingXs),
                        Text(
                          'Click to browse',
                          style: AppTheme.bodySmall.copyWith(
                            color: AppTheme.textSecondary,
                          ),
                        ),
                      ],
                    ),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildPasswordField() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Text(
              'Document Password (if applicable)',
              style: AppTheme.label,
            ),
            const SizedBox(width: AppTheme.spacing2xs),
            Icon(
              Icons.info_outline,
              size: 16,
              color: AppTheme.textSecondary,
            ),
          ],
        ),
        const SizedBox(height: AppTheme.spacingXs),
        TextFormField(
          controller: _passwordController,
          decoration: InputDecoration(
            hintText: '• • • •',
            hintStyle: AppTheme.bodyMedium.copyWith(
              color: AppTheme.textTertiary,
            ),
            helperText:
                'Allows the software to read the document if it is password protected',
            helperStyle: AppTheme.caption,
          ),
          obscureText: true,
        ),
      ],
    );
  }

  Widget _buildDocumentOwner(HomeViewModel viewModel) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Text(
              'Select the document owner',
              style: AppTheme.label,
            ),
            const SizedBox(width: 4),
            Text(
              '*',
              style: AppTheme.label.copyWith(color: AppTheme.error),
            ),
          ],
        ),
        const SizedBox(height: AppTheme.spacingXs),
        Text(
          'Contents of the document shall be associated with this participant',
          style: AppTheme.caption,
        ),
        const SizedBox(height: AppTheme.spacingXs),
        DropdownButtonFormField<int>(
          value: _selectedOwnerId,
          decoration: InputDecoration(
            hintText: 'JohnJD',
            hintStyle: AppTheme.bodyMedium.copyWith(
              color: AppTheme.textTertiary,
            ),
          ),
          validator: (value) {
            if (value == null) {
              return 'Please select a document owner';
            }
            return null;
          },
          items: viewModel.participants.map((participant) {
            return DropdownMenuItem(
              value: participant.participantId,
              child: Text(
                participant.nickName ?? participant.firstName,
                style: AppTheme.bodyMedium,
              ),
            );
          }).toList(),
          onChanged: (value) {
            setState(() {
              _selectedOwnerId = value;
            });
          },
        ),
      ],
    );
  }

  Widget _buildInstitutionSelector() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Text(
              "Select the document's financial institution",
              style: AppTheme.label,
            ),
            const SizedBox(width: 4),
            Text(
              '*',
              style: AppTheme.label.copyWith(color: AppTheme.error),
            ),
          ],
        ),
        const SizedBox(height: AppTheme.spacingXs),
        Text(
          "Can't find your bank here? Early adopters can request their institution here",
          style: AppTheme.caption,
        ),
        const SizedBox(height: AppTheme.spacingMd),
        Wrap(
          spacing: AppTheme.spacingMd,
          runSpacing: AppTheme.spacingMd,
          children: FinancialInstitution.values.map((institution) {
            final isSelected = _selectedInstitution == institution;
            return InkWell(
              onTap: () {
                setState(() {
                  _selectedInstitution = institution;
                });
              },
              child: Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: AppTheme.spacingMd,
                  vertical: AppTheme.spacingSm,
                ),
                decoration: BoxDecoration(
                  color: isSelected
                      ? AppTheme.primaryPink.withOpacity(0.1)
                      : AppTheme.surface,
                  border: Border.all(
                    color: isSelected ? AppTheme.primaryPink : AppTheme.border,
                    width: isSelected ? 2 : 1,
                  ),
                  borderRadius: BorderRadius.circular(AppTheme.radiusSm),
                ),
                child: Text(
                  institution.displayName,
                  style: AppTheme.bodyMedium.copyWith(
                    color:
                        isSelected ? AppTheme.primaryPink : AppTheme.textPrimary,
                    fontWeight: isSelected ? FontWeight.w600 : FontWeight.w400,
                  ),
                ),
              ),
            );
          }).toList(),
        ),
      ],
    );
  }

  Widget _buildActionButtons(HomeViewModel viewModel) {
    return Row(
      children: [
        Expanded(
          child: ElevatedButton.icon(
            onPressed: viewModel.isLoading ? null : _verifyAndAddDocument,
            icon: Icon(
              viewModel.isLoading
                  ? Icons.hourglass_empty
                  : Icons.verified_outlined,
              size: 20,
            ),
            label: Text(
              viewModel.isLoading
                  ? 'Verifying...'
                  : 'Verify Document and Add more',
            ),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppTheme.primaryBlue,
              padding: const EdgeInsets.symmetric(vertical: AppTheme.spacingMd),
            ),
          ),
        ),
        const SizedBox(width: AppTheme.spacingMd),
        Expanded(
          child: ElevatedButton.icon(
            onPressed: viewModel.hasDocuments && !viewModel.isLoading
                ? viewModel.runAudit
                : null,
            icon: const Icon(Icons.play_arrow, size: 20),
            label: const Text('Run Audit'),
            style: ElevatedButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: AppTheme.spacingMd),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildUploadedDocumentsList(HomeViewModel viewModel) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Uploaded Documents (${viewModel.uploadedDocuments.length})',
          style: AppTheme.h4,
        ),
        const SizedBox(height: AppTheme.spacingMd),
        ...viewModel.uploadedDocuments.map((doc) {
          return Padding(
            padding: const EdgeInsets.only(bottom: AppTheme.spacingMd),
            child: DocumentCard(document: doc),
          );
        }).toList(),
      ],
    );
  }

  Future<void> _pickFile() async {
    final result = await FilePicker.platform.pickFiles(
      type: FileType.custom,
      allowedExtensions: ['pdf'],
    );

    if (result != null && result.files.single.path != null) {
      setState(() {
        _selectedFilePath = result.files.single.path;
        _selectedFileName = result.files.single.name;
      });
    }
  }

  Future<void> _verifyAndAddDocument() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    if (_selectedFilePath == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Please select a PDF document'),
          backgroundColor: AppTheme.error,
        ),
      );
      return;
    }

    if (_selectedInstitution == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Please select a financial institution'),
          backgroundColor: AppTheme.error,
        ),
      );
      return;
    }

    final viewModel = context.read<HomeViewModel>();
    final success = await viewModel.addDocument(
      fileName: _selectedFileName!,
      filePath: _selectedFilePath!,
      password: _passwordController.text.isEmpty
          ? null
          : _passwordController.text,
      ownerParticipantId: _selectedOwnerId!,
      institution: _selectedInstitution!,
    );

    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Document verified and added: $_selectedFileName'),
          backgroundColor: AppTheme.success,
        ),
      );

      // Reset form
      setState(() {
        _selectedFilePath = null;
        _selectedFileName = null;
        _passwordController.clear();
        _selectedInstitution = null;
      });
    }
  }
}




==========================================================================================


// lib/features/home/widgets/document_card.dart

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../core/models/client_models.dart';
import '../../../core/theme/app_theme.dart';
import '../home_viewmodel.dart';

class DocumentCard extends StatelessWidget {
  final UploadedDocument document;

  const DocumentCard({
    Key? key,
    required this.document,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final viewModel = context.read<HomeViewModel>();
    final owner = viewModel.participants.firstWhere(
      (p) => p.participantId == document.ownerParticipantId,
      orElse: () => throw Exception('Participant not found'),
    );

    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingMd),
      decoration: BoxDecoration(
        color: AppTheme.surface,
        border: Border.all(color: AppTheme.border, width: 1),
        borderRadius: BorderRadius.circular(AppTheme.radiusMd),
      ),
      child: Row(
        children: [
          // PDF Icon
          Container(
            padding: const EdgeInsets.all(AppTheme.spacingSm),
            decoration: BoxDecoration(
              color: AppTheme.error.withOpacity(0.1),
              borderRadius: BorderRadius.circular(AppTheme.radiusSm),
            ),
            child: Icon(
              Icons.picture_as_pdf,
              color: AppTheme.error,
              size: 24,
            ),
          ),
          const SizedBox(width: AppTheme.spacingMd),

          // Document Info
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  document.fileName,
                  style: AppTheme.bodyMedium.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
                const SizedBox(height: 4),
                Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: AppTheme.spacingXs,
                        vertical: 2,
                      ),
                      decoration: BoxDecoration(
                        color: AppTheme.primaryPink.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(AppTheme.radiusXs),
                      ),
                      child: Text(
                        document.institution.displayName,
                        style: AppTheme.caption.copyWith(
                          color: AppTheme.primaryPink,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                    const SizedBox(width: AppTheme.spacingXs),
                    Text(
                      '• Owner: ${owner.nickName ?? owner.firstName}',
                      style: AppTheme.caption,
                    ),
                  ],
                ),
              ],
            ),
          ),

          // Delete Button
          IconButton(
            onPressed: () => _confirmDelete(context, viewModel),
            icon: Icon(
              Icons.delete_outline,
              color: AppTheme.error,
              size: 20,
            ),
            constraints: const BoxConstraints(
              minWidth: 36,
              minHeight: 36,
            ),
            padding: EdgeInsets.zero,
          ),
        ],
      ),
    );
  }

  Future<void> _confirmDelete(
    BuildContext context,
    HomeViewModel viewModel,
  ) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Remove Document'),
        content: Text('Remove ${document.fileName} from the upload queue?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            style: TextButton.styleFrom(
              foregroundColor: AppTheme.error,
            ),
            child: const Text('Remove'),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      viewModel.removeDocument(document.id);
    }
  }
}